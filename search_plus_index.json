{"./":{"url":"./","title":"前言","keywords":"","body":"Docker学习笔记 docker相关学习的笔记和其他知识点的补充 By Dazzle Lin            updated 2019-07-02 14:30:17 "},"Chapter1/容器生态系统.html":{"url":"Chapter1/容器生态系统.html","title":"容器生态系统","keywords":"","body":"容器生态系统 By Dazzle Lin            updated 2019-07-02 13:28:39 "},"Chapter1/容器核心技术.html":{"url":"Chapter1/容器核心技术.html","title":"容器核心技术","keywords":"","body":"容器规范 ​ OCI发布了两个规范：runtime spec和image format spec ​ 保证容器的可移植性和互操作性 容器runtime ​ 容器真正运行的地方，为容器提供运行环境，类似java的JVM ​ lxc、runc、rkt是目前主流的三种runtime 容器管理工具（我们常说的docker） ​ 管理容器，对内与runtime交互，对外为用户提供接口 ​ runc管理工具是docker engine(包含deamon和cli) 容器定义工具 ​ 允许用户定义容器的内容和属性，这样容器就能够被保存、共享和重建 ​ dockerfile包含若干命令的文本文件，通过该命令创建出docker image ​ docker image是Docker容器的模板，runtime依据docker image创建容器 ​ ACI（App Container Image）与docker image类似，它是由CoreOS开发的rkt容器的image格式 Registry ​ 容器通过Image创建，需要Registry仓库来统一存放image ​ 企业通过Docker Registry构建私有的Registry ​ Docker Hub（https://hub.docker.com）是Docker为公众提供的托管的Registry，有很多现成的image ​ Quay.io（https://quay.io/）是另一个公共托管Registry 容器OS ​ 容器OS是专门运行容器的操作系统。 By Dazzle Lin            updated 2019-07-02 17:02:21 "},"Chapter1/容器平台技术.html":{"url":"Chapter1/容器平台技术.html","title":"容器平台技术","keywords":"","body":"容器核心技术使容器能够在单个Host上运行，而容器平台技术能够让容器作为集群在分布式环境中运行 平台技术包括容器编排引擎、容器管理平台和基于容器的PaaS 容器编排引擎 基于微服务架构的应用系统实际上是一个动态的可伸缩的系统，我们需要一种高效的方法管理容器集群，即容器编排的目的。 编排：通常包括容器管理、调度、集群定义和服务发现。通过容器编排引擎，容器被有机组合成微服务应用，实现业务需求。 主流的容器编排引擎： docker swarm是Docker开发的容器编排引擎。 kubernetes是谷歌开发的，同时支持Docker和CoreOS容器。 mesos是一个通用的集群资源调度平台，mesos与marathon一起提供容器编排引擎功能。 容器管理平台 架构在容器编排引擎之上的更为通用的平台，通常能支持多种编排引擎，抽象了编排引擎的底层实现细节，为用户提供更方便的功能。如一键部署 Rancher和ContainerShip是代表。 基于容器的PaaS 为微服务应用开发人员和公司提供了开发、部署和管理应用的平台，使用户不必关心底层基础设施而专注应用开发 Deis、Flynn和Dokku都是开源容器PaaS的代表 By Dazzle Lin            updated 2019-07-02 17:02:31 "},"Chapter1/容器支持技术.html":{"url":"Chapter1/容器支持技术.html","title":"容器支持技术","keywords":"","body":"下列技术被用于支持基于容器的基础设施 容器网络 容器的出现使网络拓扑变的更动态和复杂。用户需要专门的解决方案和管理容器与容器、容器与其他实体之间的连通性和隔离性。 docker network是Docker原生的网络解决方案。 服务发现 动态变化是微服务应用的一大特点。 服务发现技术的工作：在这种动态环境下，必须要有一种机制让client能够知道如何访问容器提供的服务。 服务发现会保存容器集群中所有微服务最新的信息，比如Ip、端口，并对外提供API，提供服务查询功能。 etcd、consul和zookeeper是服务发现的典型解决方案。 监控 docker ps/top/stats是Docker原生的命令行监控工具。除命令行，Docker还提供stats API,用户可以通过HTTP请求获取容器的状态信息。 sysdig、cAdvisor/Heapster和Weave Scope是其他开源的容器监控方案。 数据管理 容器经常会在不同的host之间迁移，如何保证持久化数据也能动态迁移，是Rex-Ray这类数据管理工具提供的能力。 日志管理 日志为问题排查和事件管理提供重要依据。 docker logs是Docker原生的日志工具。而logspout对日志提供了路由功能，它可以收集不同容器的日志并转发给其他工具进行后处理。 安全性 OpenSCAP是一种容器安全工具，能对容器镜像进行扫描，发现潜在漏洞。 By Dazzle Lin            updated 2019-07-02 17:03:40 "},"Chapter1/CentOS7部署docker.html":{"url":"Chapter1/CentOS7部署docker.html","title":"CentOS7部署docker","keywords":"","body":"docker 在线安装 docker是容器的基础服务，而shipyard是查看容器的界面服务（也是运行在docker上的容器服务） 卸载旧版本 yum remove -y docker docker-common docker-selinux docker-engine yum install -y wget systemctl stop firewalld systemctl disable firewalld 为什么选择关闭防火墙请阅读https://blog.lab99.org/post/docker-2016-07-14-faq.html#wei-shi-me-p-hou-huan-shi-wu-fa-tong-guo-ying-she-duan-kou-fang-wen-rong-qi-li-mian-de-fu-wu 获取官方源 wget -P /etc/yum.repos.d/ https://download.docker.com/linux/centos/docker-ce.repo 用下面的命令可以查看可以安装的版本 yum list docker-ce --showduplicates | sort -r 其中有3列信息，第1列：软件包名称、第2列：版本字符串、第3列：仓库名称 比方想安装docker ce的版本18.03.0 yum install -y docker-ce- yum install -y docker-ce-18.03.0.ce-1.el7.centos 启动、开机启动 systemctl start docker systemctl enable docker 开放2375端口 firewall-cmd --zone=public --permanent --add-port=2375/tcp firewall-cmd --reload 试验安装是否成功、查看版本 docker run hello-world docker version 设置镜像加速器 墙的缘故，访问docker hub不够稳定，故需要设置镜像加速器来解决这个问题。 这里使用的是阿里云的镜像加速器。 登录阿里云后，访问https://cr.console.aliyun.com/#/accelerator （registry-mirrors的值必须带https:// （阿里云的教程中只有域名），否则会出现docker重启报错的情况。） 离线安装 建立docker用户组 # 建立docker组 sudo groupadd docker # 将当前用户加入docker组 sudo usermod -aG docker $USER 待续 卸载 yum list installed | grep docker 删除安装的软件包 [root@sungeek ~]# yum -y remove docker-common.x86_64 删除镜像/容器等 [root@sungeek ~]# rm -rf /var/lib/docker/ 输入docker或docker --version验证是否卸载 导入加载进来觉得不合适可以使用 docker rm 容器ID 、 docker rmi 镜像ID 来删掉 移除所有的容器和镜像 docker kill $(docker ps -q) ; docker rm $(docker ps -a -q) ; docker rmi $(docker images -q -a) 获取应用栈各节点所需镜像 docker pull ubuntu docker pull django docker pull haproxy docker pull redis 应用栈各节点连接信息如下： ​ 启动redis-master节点 ​ 两个redis-slave节点启动时要连接到master ​ 两个APP节点启动要连接到master ​ Haproxy节点启动要连接到两个APP节点 启动顺序：redis-master——>redis-slave——>APP——>haproxy 为了外网可以访问应用栈，haproxy需要暴露端口给主机 节点启动 #启动redis容器 docker run -it --name redis-master redis /bin/bash docker run -it --name redis-slave1 --link redis-master:master redis /bin/bash docker run -it --name redis-slave2 --link redis-master:master redis /bin/bash #启动Django容器 docker run -it --name APP1 --link redis-master:db -v ~/Projects/Django/App1:/usr/src/app django /bin/bash docker run -it --name APP2 --link redis-master:db -v ~/Projects/Django/App2:/usr/src/app django /bin/bash #启动HAProxy容器 docker run -it --name HAProxy --link APP1:APP1 --link APP2:APP2 -p 6301:6301 -v ~/Projects/HAProxy:/tmp haproxy /bin/bash 节点配置 实现特定的功能和通讯协作 关闭redis:redis-cli -p 端口号 shutdown Redis-master [root@lqy-ali home]redis-server -v [root@lqy-ali home]docker inspect --format \"{{.Mounts}}\" containerId [root@lqy-ali home]# cd /var/lib/docker/volumes/cb4866ddee3b7391dd492f186c30b20768b33e613a5267bc9a9ed6b174d64e8e/_data [root@lqy-ali cb4866ddee3b7391dd492f186c30b20768b33e613a5267bc9a9ed6b174d64e8e]# cp /home/redis.conf redis.conf [root@lqy-ali cb4866ddee3b7391dd492f186c30b20768b33e613a5267bc9a9ed6b174d64e8e]# vi redis.conf 需要修改2个参数 bind 0.0.0.0 daemonize yes pidfile /var/run/redis.pid 主机创建完成启动配置文件后，切换到volume目录中，复制启动文件至redis执行目录，启动redis服务器 root@c693354bdeff:/data# ls redis.conf root@c693354bdeff:/data# cp redis.conf /usr/local/bin/ root@c693354bdeff:/data# cd /usr/local/bin/ root@c693354bdeff:/usr/local/bin# ls docker-entrypoint.sh gosu redis-benchmark redis-check-aof redis-check-rdb redis-cli redis-sentinel redis-server redis.conf root@c693354bdeff:/usr/local/bin# redis-server redis.conf 13:C 18 May 2019 03:13:53.977 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo 13:C 18 May 2019 03:13:53.977 # Redis version=5.0.5, bits=64, commit=00000000, modified=0, pid=13, just started 13:C 18 May 2019 03:13:53.977 # Configuration loaded Redis-Slave 其余都一样，除了修改启动配置文件 daemonize yes pidfile /var/run/redis.pid slaveof master 6379 slaveof使用格式为slaveof ，用--link参数设置的连接名来代替真实IP。 通过连接名互连通信，容器会自动读取它host信息，将连接名转换为实际IP地址 Redis数据库节点测试 master上先存一个值，然后去另外两台查询是否有值 APP容器配置 为了访问数据库，需要在容器中安装Python语言的Redis支持包 pip install redis #测试安装 root@8089581e353e:/# python Python 3.4.5 (default, Dec 14 2016, 18:54:20) [GCC 4.9.2] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import redis >>> print(redis.__file__) /usr/local/lib/python3.4/site-packages/redis/__init__.py 在容器的voleme目录下/usr/src/app/下开始创建app #容器内 root@8089581e353e:/# cd /usr/src/app/ root@8089581e353e:/usr/src/app# mkdir dockerweb root@8089581e353e:/usr/src/app# cd dockerweb/ root@8089581e353e:/usr/src/app/dockerweb# django-admin.py startproject redisweb root@8089581e353e:/usr/src/app/dockerweb# ls redisweb root@8089581e353e:/usr/src/app/dockerweb# cd redisweb/ root@8089581e353e:/usr/src/app/dockerweb/redisweb# ls manage.py redisweb root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py startapp helloworld root@8089581e353e:/usr/src/app/dockerweb/redisweb# ls helloworld manage.py redisweb 切换成主机的volume目录来修改配置APP [root@lqy-ali App1]# cd dockerweb/redisweb/helloworld/ [root@lqy-ali helloworld]# ls admin.py apps.py __init__.py migrations models.py tests.py views.py [root@lqy-ali helloworld]# vi views.py views.py文件如下： from django.shortcuts import render from django.http import HttpResponse import redis def hello(request): str=redis.__file__ str+=\"\" r=redis.Redis(host='db',port=6379,db=0) info=r.info() str+=(\"Set Hi \") r.set('Hi','HelloWorld-APP1') str+=(\"Get Hi:%s \" % r.get('Hi')) str+=(\"Redis Info:\") str+=(\"Key: Info Value\") for key in info: str+=(\"%s:%s \" % (key,info[key])) return HttpResponse(str) 连接Redis数据库时，使用--link参数创建db连接来代替具体的IP地址 修改redisweb项目的配置文件setting.py，添加新建的helloworld应用 ALLOWED_HOSTS = ['121.196.195.191'] INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'helloworld', ] 修改redisweb项目的URL模式文件urls.py,它将设置访问应用的URL模式，并为URL模式调用视图函数之间的映射表。 vi urls.py 在urls.py文件中，引入helloworld应用的hello视图，并为hello视图添加一个urlpatterns变量 from django.conf.urls import url from django.contrib import admin from helloworld.views import hello urlpatterns = [ url(r'^admin/', admin.site.urls), url(r'^helloworld$',hello), ] 进入容器，在目录/usr/src/app/dockerweb/redisweb下完成项目生成 root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py makemigrations No changes detected root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying sessions.0001_initial... OK root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py syncdb Unknown command: 'syncdb' Type 'manage.py help' for usage. #为数据库中每个应用建立一个数据库表,在Django 1.9及未来的版本种使用migrate代替syscdb root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py migrate Operations to perform: Apply all migrations: admin, auth, contenttypes, sessions Running migrations: No migrations to apply. 启动指定ip和端口 root@8089581e353e:/usr/src/app/dockerweb/redisweb# python manage.py runserver 0.0.0.0:8001 Performing system checks... System check identified no issues (0 silenced). May 18, 2019 - 04:34:45 Django version 1.10.4, using settings 'redisweb.settings' Starting development server at http://0.0.0.0:8001/ Quit the server with CONTROL-C. HAProxy容器节点配置 HAProxy启动配置文件复制进容器 [root@lqy-ali redisweb]# cd ~/Projects/HAProxy/ [root@lqy-ali HAProxy]# ls [root@lqy-ali HAProxy]# vi haproxy.cfg global log 127.0.0.1 local0 #日志输出配置，所有日志都记录在本机，通过local0输出 maxconn 4096 #最大连接数 chroot /usr/local/sbin #改变当前工作目录 daemon #以后台形式运行HAProxy nbproc 4 #启动4个HAProxy实例 pidfile /usr/local/sbin/haproxy.pid #pid文件位置 defaults log 127.0.0.1 local3 #日志文件的输出定向 mode http #{tcp|http|health}设定启动实例的协议类型 option dontlognull #保证HAProcy不记录上级负载均衡发送过来的用于检测状态没有数据的心跳包 option redispatch #当serverId对应的服务器挂掉后，强制定向到其他健康的服务器 retries 2 #重试两次连接失败就认为服务器不可用，主要通过后面的check检查 maxconn 2000 #最大连接数 balance roundrobin #balance有两个可用选项：roundrobin和source,其中,roundrobin表示轮询，而source表示HAProxy不采用轮询的策略，而是把来自某个IP的请求转发给一个固定IP的后端 timeout connect 5000ms #连接超时时间 timeout client 50000ms #客户端连接超时时间 timeout server 50000ms #服务器端连接超时时间 listen redis_proxy 0.0.0.0:6301 stats enable stats uri /haproxy-stats server APP1 APP1:8001 check inter 2000 rise 2 fall 5 #你得均衡节点 server APP2 APP2:8002 check inter 2000 rise 2 fall 5 进入容器的volume目录/tmp下，将HAProxy启动配置文件复制到HAProxy的工作目录中 root@bbf0225f40d2:/# cd /tmp/ root@bbf0225f40d2:/tmp# cp haproxy.cfg /usr/local/sbin/ root@bbf0225f40d2:/tmp# cd /usr/local/sbin/ root@bbf0225f40d2:/usr/local/sbin# ls haproxy haproxy.cfg 启动HAProxy代理 root@bbf0225f40d2:cd /tmp root@bbf0225f40d2:/tmp# cp haproxy.cfg /usr/local/sbin/ root@bbf0225f40d2:/tmp# cd /usr/local/sbin/ root@bbf0225f40d2:/usr/local/sbin# haproxy -f haproxy.cfg 如果修改了配置文件的内容，需要先结束所有的HAProxy进程，并重启代理，killall命令来结束进程 yum install psmisc killall haproxy By Dazzle Lin            updated 2019-07-02 19:17:32 "},"Chapter2/容器核心概论.html":{"url":"Chapter2/容器核心概论.html","title":"容器核心概论","keywords":"","body":"容器使软件具备了超强的可移植能力。 docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。 Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。 容器可以运行在几乎所有的操作系统上。 容器意味着环境隔离和可重复性。 开发人员只需为应用创建一次运行环境，然后打包成容器便可在其他机器上运行。 容器环境与所在的Host环境是隔离的。 By Dazzle Lin            updated 2019-07-02 14:45:17 "},"Chapter2/Docker的核心组件.html":{"url":"Chapter2/Docker的核心组件.html","title":"Docker的核心组件","keywords":"","body":" Docker客户端：Client docker命令，也可通过REST API与服务器通信 Docker服务端：Docker daemon 服务器组件，运行在Host上，负责创建、运行、监控容器，构建、存储镜像 默认只响应本地客户端请求，如果需要允许远程客户端请求，需要打开TCP监听。 1.路径：/etc/systemd/system/multi-user.target.wants/docker.service 允许来自任意IP的客户端连接 ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0 不同系统配置文件位置可能不同 2.重启Docker daemon systemctl daemon-reload systemctl restart docker.service 3.服务器IP为192.168.1.102，客户端在命令行加上-H参数，即可远程通信 docker -H 192.168.1.102 info info命令可以查看Docker服务器信息 Docker镜像：Image 只读模板，可以创建容器 生成方法：从无到有开始创建镜像、下载并使用别人现成的镜像、在现有镜像之上创建新镜像 可以将镜像内容和创建步骤描述在文本文件中，称为Dockerfile,通过执行docker build 命令可以构建Docker镜像 Registry 存放Docker镜像的仓库，分公有和私有两种 Docker Hub(https://hub.docker.com/)是默认的Registry docker pull：下载镜像 docker run：先下载镜像（本地没有），再启动容器 docker ps或docker container ls显示容器正在运行 Docker容器：Container By Dazzle Lin            updated 2019-07-02 14:51:43 "},"Chapter2/Docker镜像.html":{"url":"Chapter2/Docker镜像.html","title":"Docker镜像","keywords":"","body":"镜像是Docker容器的基石，容器是镜像的运行实例，有了镜像才能启动容器。 最小的镜像，hello-world Dockerfile内容 FROM scratch 从0开始构建 COPY hello / 将文件“hello”复制到镜像的根目录 CMD [\"/hello\"] 容器启动时，执行/hello base镜像 base镜像：镜像能提供一个基本的操作系统环境，用户可以根据需要安装和配置软件 base镜像两层含义： 1.不依赖其他镜像，从scratch构建 2.其他镜像可以以之为基础进行扩展 Linux镜像上层提供各自的rootfs，底层共用Docker Host的kernel 1.base镜像只是在用户空间与发行版一致，kernel版本与发行版不同 容器只能使用Host的kernel版本，并且不能修改 如果容器对kernel版本有要求，则不建议用容器 镜像的分层结构 Docker支持通过扩展现有镜像，创建新的镜像。 新镜像是从base镜像一层一层叠加生成 最大的好处是：共享资源 可写的容器层 当容器启动时，一个新的可写层被加载到镜像顶部。 只有容器层可写，容器层之下叫镜像层，只读。 容器Copy-on-Write特性：只有当需要修改时才复制一份数据 容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改,修改会被限制在单个容器内,镜像可以被多个容器共享。 构建镜像 Docker提供两种构建镜像的方法： docker commit命令（不提倡） 运行容器 修改容器 将容器保存为新镜像 1.运行容器 [root@lqy-ali /]# docker run -it centos [root@1c6a8a5e010d /]# -it参数的作用：以交互模式进入容器，并打开终端，1c6a8a5e010d是容器内部ID。 2.vim安装 [root@1c6a8a5e010d /]# vim bash: vim: command not found 安装Vim [root@1c6a8a5e010d /]# yum install -y vim Loaded plugins: fastestmirror, ovl Determining fastest mirrors * base: mirrors.cn99.com * extras: mirrors.cn99.com * updates: mirrors.cn99.com 3.保存为新镜像 新窗口查看当前运行容器 modest_boyd是Docker为容器随机分配的名字 执行docker commit命令将容器保存为镜像 [root@lqy-ali ~]# docker commit modest_boyd centos-with-vim sha256:e5190a01b8bed8ca4dc715bea7bc2fb2a0daf15a923563bd12c05f636ab448b3 新镜像命名centos-with-vim 4.从新镜像启动容器，验证vi可以使用 不提倡原因 1.手工创建镜像的方式，容易出错，效率低且可重复性弱 2.无法对镜像进行审计，存在安全隐患 Dockerfile构建文件（推荐） 记录了镜像构建的所有步骤 [root@lqy-ali ~]# pwd /root [root@lqy-ali ~]# touch Dockderfile [root@lqy-ali ~]# ls Dockerfile //必须这么命名 [root@lqy-ali ~]# vi Dockderfile [root@lqy-ali ~]# cat Dockderfile FROM centos RUN yum install -y vim [root@lqy-ali ~]# docker build -t centos-with-vim-dockerfile . 查看镜像分层结构 docker history会显示镜像的构建历史，也就是Dockerfile的执行过程 镜像的缓存特性 Docker会缓存已有镜像的镜像层，构建新镜像时，如果某镜像层已经存在，就直接使用，无需重新创建。 不使用缓存：在docker build中加上--no-cache参数 Dockerfile中每个指令都会创建一个镜像层，上层依赖下层。无论何时，只要某一层发生改变，或删除或修改或执行顺序改变，其上面所有层的缓存都会失效。 调试Dockerfile 通过Dockerfile构建镜像的过程： 1.从base镜像运行一个容器 2.执行一条指令，对容器做修改 3.执行类似docker commit操作，生成新的镜像层 4.Docker再基于刚刚提交的镜像运行一个新容器 5.重复2-4步，直到Dockerfile中所有指令执行完毕 由于某种原因执行到某个指令失败，我们也能得到前一个指令成功执行构建出的镜像。 Dockerfile常用指令(支持“#”开头的注释) FROM 指定base镜像 MAINTAINER 设置镜像作者，可以任意字符串 COPY 将文件从build context复制到镜像 支持两种形式：COPY src dest与COPY[\"src\",\"dest\"] src只能指定build context中的文件或目录 ADD 与COPY类似，区别是如果src是归档文件（tar\\zip等），文件自动解压到dest ENV 设置环境变量，可被后面命令使用 ENV MY_VERSION 1.3 RUN yum install -y mypackage=$MY_VERSION EXPOSE 指定容器中的进程会监听某个端口，Docker可以将该端口暴露 VOLUME 将文件或目录声明为volume WORKDIR 为后面的RUM、CMD、EXTRYPOINT、ADD、COPY指令设置镜像中的当前工作目录 RUN vs CMD vs ENTRYPOINT RUN 经常用于安装软件包，在当前镜像的顶部执行命令并创建新的镜像层，一个Dockerfile可包含多个 CMD 设置容器启动后默认执行的命令及其参数 此命令会在容器启动且docker run没有指定其他命令时运行 如果docker run指定其他命令，CMD指定的默认命令将被忽略 如果Dockerfile存在多个CMD指令,只有最后一个CMD有效 ENTRYPOINT 与CMD很类似，可让容器以应用程序或服务形式运行，不会被忽略，一定会执行 Dockerfile中可以存在多个ENTRYPOINT指令，但只有最后一个生效 ENTRYPOINT中的参数始终会被使用，而CMD额外参数可以在容器启动时动态替换掉 例： ENTRYPOINT [\"/bin/echo\",\"Hello\"] CMD [\"world\"] 当容器通过docker run -it [image]启动 Hello world 当容器通过docker run -it [image] CloudMan Hello CloudMan ENTRYPOINT的Shell格式会忽略任何CMD或docker run提供的参数 Shell和Exec格式指定RUN、CMD、ENTRYPOINT要运行的命令 Shell格式 例: ENV name Cloud Man ENTRYPOINT echo \"Hello,$name\" 结果： Hello,Cloud Man Exec格式(推荐CMD、ENTRYPOINT) [\"executable\",\"param1\",\"param2\",....] RUN [\"yum\",\"install\", \"python3\"]=>RUN yum install python3 当命令执行时，会直接调用command，不会被shell解析 例： ENV name Cloud Man ENTRYPOINT [\"/bin/echo\",\"Hello,$name\"] 结果： Hello,$name 环境变量name未被替换 修改： ENV name Cloud Man ENTRYPOINT [\"/bin/sh\",\"-c\",\"echo Hello,$name\"] 分发镜像 为镜像命名 一个特定镜像的名字由两部分组成：repository和tag [image name]=[repository]:[tag] 若docker build没指定tag，默认latest，类似 docker build -t centos-with-vim:latest tag常用于描述镜像的版本信息 打tag编号规范必须参考书，p49 使用公共Registry Docker Hub [root@lqy-ali ~]# docker login -u linqinye2019 Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded Docker Hub为了区分不同用户的同名镜像，镜像的registry中要包含用户名，完整格式：[username]/xxx:tag 通过docker tag命令重命名镜像，docker push上传镜像 quay.io 搭建本地Registry 1.启动registry容器 [root@lqy-ali ~]# docker run -d -p 5000:5000 -v /myregistry:/var/lib/registry registry:2 Unable to find image 'registry:2' locally 2: Pulling from library/registry c87736221ed0: Pull complete 1cc8e0bb44df: Pull complete 54d33bcb37f5: Pull complete e8afc091c171: Pull complete b4541f6d3db6: Pull complete Digest: sha256:77a8fb00c00b99568772a70f0863f6192ff2635e4af4e22e4d9c622edeb5f2de Status: Downloaded newer image for registry:2 74c7f22c857d688f466e6a741c052fd1b7942e6a6b8f9fed632292d726148e63 -d:后台启动容器 -p:将容器的5000端口映射到Host的5000端口。5000是registry服务端口。 -v:将容器/var/lib/registry目录映射到Host的/myregistry，用于存放镜像数据。 通过docker tag重命名镜像 [root@lqy-ali ~]# docker tag linqinye2019/centos-with-vim-dockerfile:v1 127.0.0.1:5000/linqinye2019/centos-with-vim-dockerfile:v1 Registry镜像名称完整格式：[registry-host]:[port]/[username]/xxx 2.docker push上传镜像 [root@lqy-ali ~]# docker push 127.0.0.1:5000/linqinye2019/centos-with-vim-dockerfile The push refers to repository [127.0.0.1:5000/linqinye2019/centos-with-vim-dockerfile] ee4e5f1e6694: Pushed d69483a6face: Pushed v1: digest: sha256:59d34981221de989dc4f8db95de4aad7178d007631b7daec2df084a24fa419c9 size: 741 3.docker pull从本地registry下载 [root@lqy-ali ~]# docker pull 127.0.0.1:5000/linqinye2019/centos-with-vim-dockerfile:v1 v1: Pulling from linqinye2019/centos-with-vim-dockerfile Digest: sha256:59d34981221de989dc4f8db95de4aad7178d007631b7daec2df084a24fa419c9 Status: Downloaded newer image for 127.0.0.1:5000/linqinye2019/centos-with-vim-dockerfile:v1 Docker镜像常用操作子命令 docker命令的执行一般要获取root权限 原因 因为Docker的命令行工具docker与Docker daemon是同一个二进制文件，而Docker daemon负责接手并执行来自docker的命令，它的运行需要root权限。从Docker 0.5.2版本开始，Docker daemon默认绑定一个Unix Socket来代替原有的TCP端口，该Unix Socket默认属于root用户，因此执行docker命令时，需要使用sudo获取root权限。 docker command --help获取详细子命令信息,例如：docker start --help images:显示镜像列表 history:打印出指定镜像的历史版本信息，即构建该镜像的每一层镜像的命令记录 events:打印出实时的系统日志 logs：打印出容器中进程的运行日志 commit:从容器创建新镜像 build:从Dockerfile构建镜像 tag:给镜像打tag pull:从Registry下载镜像 push:将镜像上传到registry rmi:删除Docker host中的镜像（-f强制删除存在容器的镜像） ​ 只能删除host上的镜像，不会删除registry的镜像 ​ 如果 一个镜像对应多个tag,只有当最后一个tag被删除时，镜像才被真正删除 ​ 如果存在基于该镜像启动得容器，则无法直接删除，需要先删除容器。 删除所有镜像 docker rmi `docker images -q` ​ 按条件删除镜像 没有打标签 docker rmi `docker images -q | awk '/^/ { print $3 }'` 镜像名包含关键字 docker rmi --force `docker images | grep doss-api | awk '{print $3}'` //其中doss-api为关键字 search:搜索Docker Hub中的镜像 ​ 无须打开浏览器就可以搜索镜像 inspect:查看镜像和容器得详细信息，默认列出全部信息，可通过--format参数来指定输出模板格式 查看容器得内部IP docker inspect --format='{{.NetworkSettings.IPAddress}}' imagesId ps:查看容器得相关信息，默认只显示正在运行得容器得信息 ​ -a:查看所有容器，包括停止得容器 ​ -l:只查看最新创建的容器，包括不在运行中的容器 By Dazzle Lin            updated 2019-07-02 15:32:20 "},"Chapter2/Docker容器.html":{"url":"Chapter2/Docker容器.html","title":"Docker容器","keywords":"","body":"运行容器 三种方式指定容器启动 时执行的命令： 1.CMD 2.ENTRYPOINT 3.docker run docker ps或docker container ls：查看Docker host中当前运行的容器 -a会显示所有状态的容器。 容器长期运行 容器的生命周期依赖于启动时执行的命令，只要该命令不结束，容器就不会退出。 docker run image /bin/bash -c \"while true;do sleep 1;done\" while语句让base不会退出，但占用了一个终端。 加上参数-d以后台方式启动容器。 docker run -d image /bin/bash -c \"while true;do sleep 1;done\" 容器启动返回终端，返回一串容器ID（容器的长ID） --link参数 能够进行容器间安全的交互通信，使用格式 name:alias 可在一个docker run命令中反复使用该参数 docker run --link redis:redis --name console ubuntu bash 解析： 在Ubuntu镜像上启动一个容器，并命名为console，同时将新启动的console容器连接到名为redis的容器上。在使用--link选项时，连接通过容器名来确定容器，建议启动容器时自定义名称 优点： 不但可以避免容器的IP和端口暴露到外网所导致的安全问题，还可以防止容器在重启后IP地址变化导致的访问问题。原理类似DNS服务器域名和地址映射，当容器IP地址发生变化，Docker会自动维护映射关系中的IP地址 docker run -it --name redis-slave1 --link redis-master:master redis /bin/bash #容器内查看/etc/hosts文件 cat /etc/hosts 可以将--link设置可以理解为一条IP地址的单向记录信息，因此在搭建容器应用栈时，需要注意各容器节点的启动顺序，以及对应的--link参数设置。 docker ps查看两个字段 CONTAINER ID 容器的短ID，是长ID的前12个字符 NAME 容器的名字，启动时加--name显式命名，重命名容器可执行docker rename。不指定则docker会自动分配 借助短ID停止容器 docker stop 短ID 通过while启动容器无意义，一般通过后台启动，即-d 两种进入容器的方法 docker attach 可以连接到正在运行得容器，观察该容器得运行情况或与容器得主进程进行交互 通过\"长ID\"attach到容器的启动命令终端 注：通过Ctrl+p，然后Ctrl+q组合键退出attach终端 docker exec docker exec -it 短id bash 1.-it以交互模式打开pseudo-TTY，执行bash，其结果打开一个bash终端 2.进入到容器中，容器的hostname就是短ID 3.可以类似Linux一样执行命令，ps -elf显示了容器启动进程while以及当前的bash进程 4.执行exit退出容器 exec常规格式 docker exec -it bash|sh attach VS exec 1.attach直接进入容器启动命令的终端。不会启动新的进程 2.exec在容器中打开新的终端，并且可以启动新的进程 3.如果想直接在终端查看启动命令输出用attach，其余用exec 单纯想查看启动命令输出也可以用以下 docker logs -f 短ID 指定容器三种方式 短ID 长ID 容器名称 容器分类 按用途容器分两类 服务类（多提供服务） 以daemon形式运行，对外提供服务，比如数据库等，通过-d以后台方式启动，exec -it进入容器排查问题。 工具类（多使用基础镜像） 能提供临时的工作环境。以run -it运行，如下 docker run -it busybox run -it作用：在容器启动后就直接进入。执行exit退出终端且停止容器。 stop/start/restart容器 容器在docker host上实际上就是一个进程 docker stop：向该进程发送一个SIGTERM信号。 docker stop image-name docker kill：向容器进程发送SIGKILL信号 docker kill image-name docker start：处于停止状态的容器，重新启动。(会保留容器第一次启动时的所有参数) -i参数来开启交互模式，始终保持输入流开放 -a参数附加标准输入输出和错误输出 docker start image-name docker restart：本质是依次执行docker stop和docker start 容器可能会因某种错误而停止运行，对于服务类容器，我们希望它自动重启 启动容器时设置--restart即可。例子如下： docker run -d --restart=always httpd --restart=always意味着无论容器因何种原因退出（包括正常退出），都立即重启；该参数的形式也可以--restart=on-failure:3，意思是如果启动进程退出代码非0，则重启容器，最多重启3次。 docker stop和docker restart使用-t来设定容器停止前得等待时间 pause/unpause容器 docker pause image-name 容器暂停工作状态，不占用CPU资源 docker unpause image-name 恢复运行 删除容器 使用一段时间后可能会有大量已经退出的容器。依然会占用Host得文件系统资源，如果确认不再启用，可以删除 docker rm imageId1 imageId2 docker rm一次可以指定多个容器，删除所有已经退出得容器，可以用以下命令 docker rm -v $(docker ps -aq -f status=exited) docker rm是删除容器，docker rmi删除镜像 State Machine 容器各种状态转换 1.先创建容器，稍后启动 docker create httpd 容器处于Created状态 docker start containerId 以后台方式启动容器 docker run=docker create+docker start 2.只有当容器启动进程退出时，--restart才有效，举例 启动进程正常退出或发生OOM，此时Docker根据--restart策略判断是否需要重启容器。 如果容器时因为执行docker stop或docker kill退出，则不会自动重启 资源限制 内存限额 控制容器内存使用量 1.-m或--memory：设置内存得使用限额，例如100MB，2GB 2.--memory-swap：设置内存+swap得使用限额 docker run -m 200M --memory-swap=300M ubuntu 允许容器最多使用200M的内存和100MB的swap。 默认两个参数为-1，即对容器内存和swap的使用没限制 docker run -m 200M --memory-swap=300M ubuntu --vm 1 --vm-bytes 280M --vm 1:启动1个内存工作线程 --vm-bytes 280M：每个线程分配280MB内存 因为280M在300M之内，所以工作线程能正常工作，过程： 1.分配280 2.释放280 ....... 5.一直循环。。。 分配的内存超过限额，线程报错，容器退出。 启动容器时只指定-m没指定--memory-swap，则--memory-swap默认为-m的两倍 docker run -it -m 200M ubuntu =>docker run -it -m 200M --memory-swap=400M ubuntu 容器最多使用200MB物理内存和200MBswap。 CPU限额——类似设置容器使用CPU的优先级 默认设置下，所有容器平等使用host CPU资源并且无限制 Docker通过-c或--cpu-shares设置容器使用CPU的权重。不指定默认1024. 与内存不同，设置的CPU权重不是绝对数量，而是相对的。 某容器能分配的CPU取决于它的cpu share占所有容器cu share总和的比例。 docker run --name container-A -c 1024 ubuntu docker run --name container_B -c 512 ubuntu 注意：权重分配CPU只发生在CPU资源紧张的情况下。 --cpu用来设置工作线程的数量。 docker run --name conb -it -c 1024 progrium/stress --cpu 2 Block IO带宽限额 限制磁盘的读写，docker通过设置权重、限制bps和iops控制容器读写磁盘带宽 目前只对direct IO（不使用文件缓存）有效 --blkio-weight 改变容器block IO优先级，设置的是相对权重，默认500 限制bps(byte per second/每秒读写数据量)和iops(io per second/每秒IO的次数) --device-read-bps:限制读某设备的bps --device-write-bps --device-read -iops --device-write-iops docker run -it --device-write-bps /dev/sda:30M ubuntu time dd if=/dev/zero of=test.out bs=1M count=800 oflag=direct dd测试容器中写磁盘的速度，oflag=direct指定用direct IO方式写文件才有效。 实现容器的底层技术 cgroup Conrol Group 实现资源限额 前面的资源限制操作就是在配置cgroup /sys/fs/cgroup/cpu/docker，以容器长ID命名 [root@lqy-ali ~]# docker run -it --cpu-shares 512 progrium/stress -c 1 stress: info: [1] dispatching hogs: 1 cpu, 0 io, 0 vm, 0 hdd stress: dbug: [1] using backoff sleep of 3000us stress: dbug: [1] --> hogcpu worker 1 [6] forked /sys/fs/cgroup/cpu/docker /sys/fs/cgroup/memory/docker：内存的cgroup配置 /sys/fs/cgroup/blkio/docker：Block IO的cgroup配置 namespace 实现容器间资源隔离。 namespace管理着Host中全局唯一的资源，并可以让每个容器都觉得只有自己在使用它。 6个namespace: mount namespace:让容器看上去拥有整个文件系统 UTS namespace:让容器拥有自己的hostname，默认容器的hostname是短ID，通过-h或-hostname参数设置 IPC namespace:让容器拥有自己的共享内存和信号量来实现进程间通信，跟其他容器隔离 PID namespace:容器有自己独立的一套PID (ps axf) Network namespace:让容器有独立的网卡、IP、路由 User namespace:容器可管理自己的用户，host不能看到容器创建的用户 namespace的4种方式 setns():加入一个已经存在的namespace clone():在创建新进程的同时创建namespace unshare():在原先进程上进行namespace隔离 常用容器的操作指令 create:创建容器 run:运行容器 pause:暂停容器 unpause:取消暂停继续运行容器 stop:发送SIGTERM停止容器 kill:发送SIGKILL快速停止容器 start:启动容器 restart：重启容器 attach:attach到容器启动进程的终端 exec:在容器中启动新进程，通常使用-it logs:显示容器启动进程的控制台输出，用-f持续打印 rm:从磁盘中删除容器 By Dazzle Lin            updated 2019-07-02 15:36:38 "},"Chapter2/Docker网络.html":{"url":"Chapter2/Docker网络.html","title":"Docker网络","keywords":"","body":"Docker安装时会自动在host上创建三个网络，docker network ls命令查看 none网络 除了lo，其余都没有，可通过--network=none指定 docker run -it --network=none busybox 封闭意味着隔离，适用于安全性要求高且不需要联网的应用，比如生成随机密码 host网络 连接到host网络的容器共享Docker host的网络栈。可通过--network=host指定 最大的好处是性能，若容器对网络传输效率有较高要求，可以选择host网络。牺牲一些灵活性，Docker host上使用过的端口不能再用。 另一个用途是让容器可以直接配置host网路。 bridge网络 docker容器默认的网络 安装bridge-utils工具包 yum -y install bridge-utils yum -y install initscripts brctl show //当前host的网络结构 veth2121b73即新创建容器的虚拟网卡。容器中会存在对应的网卡。容器网卡和veth2121b73是一对veth pair。veth pair是一种成对出现的特殊网络设备，可以想象成一根虚拟网线连接起来的一对网卡，一头在容器中，另一头veth2121b73挂网桥docker0上，其效果就是将容器网卡也挂在了docker0上。 docker network inspect bridge 网关就是docker0 容器创建时，docker会自动从172.17.0.0/16中分配一个IP。 user-defined网络 根据业务需要自主创建user-defined网络 Docker提供三种user-defined网络驱动：bridge、创建跨主机的网络(overlay和macvlan)。 通过bridge驱动创建bridge网络 docker network create --driver bridge my_net 新增一个网桥br-a9ee1053f761，a9ee1053f761正好是新建bridge网络my_net短ID 指定IP网段 --subnet和--gateway参数 docker network create --driver bridge --subnet 172.22.16.0/24 --gateway 172.22.16.1 my_net2 容器要使用新的网络，需要启动时通过--network指定 docker run -it --network=my_net2 busybox 指定静态IP(只有使用--subnet创建的网络才能指定静态IP) 目前为止容器的IP都是docker自动从subnet中分配 docker run -it --network=my_net2 --ip 172.22.16.8 busybox 两个busybox容器都挂在my_net2上，同一网络中的容器、网关之间网络互通 两个网络属于不同的网络，无法通信。 不同的网络加上路由可以通信。 host上对每个都有一条路由，同时操作系统上打开了ip forwarding，host就成了路由器，挂载在不同网桥上的网络就能够相互通信。 检查 ip r //查看host上的路由表 查看ip forwarding是否启用 [root@lqy-ali ~]# sysctl net.ipv4.ip_forward net.ipv4.ip_forward = 1 //已启用 原因 iptables-save iptables DROP掉不同网桥之间的双向流量 从规则命名DOCKER-ISOLATION可知docker在设计上就要隔离不同的network 如何才让不同网络通信 为httpd容器添加一块net_my2网卡，通过docker network connect（将现有容器加入指定网络）实现 docker network connect my_net2 httpd容器短ID 之后就可以访问了 。 容器间通信 容器之间可通过IP、Docker DNS Server或joined容器三种方式通信 IP通信 两个容器要通信，必须要有属于同一个网络的网卡。 缺点： 不够灵活，部署应用之前可能无法确定IP，部署之后再指定要访问IP，较麻烦 具体做法： 容器创建时通过--network指定相应网络，或通过docker network connect将现有容器加入指定网络。 Docker DNS Server Docker 1.10版本后，docker daemon（服务端）实现了内嵌DNS server，使容器可以直接通过容器名通信。 具体做法： 启动时用--name为容器命名 docker run -it --network=my_net2 --name=bbox1 busybox docker run -it --network=my_net2 --name=bbox2 busybox 在bbox2容器中能ping到bbox1. 限制 只能在user-defined网络使用，默认的bridge网络无法使用DNS joined容器 非常特别，可以使两个或多个容器共享一个网络栈，共享网卡和配置信息，joined容器之间可通过127.0.0.1直接通信。 测试： docker run -d -it --name=web1 httpd 指定joined容器为web1 docker run -it --network=container:web1 busybox busybox和web1的网卡mac地址与IP完全一样，它们共享了相同的网络栈。busybox直接可以用127.0.0.1访问web1的http服务。 适用场景： 1.不同容器中的程序希望通过loopback高效快速地通信，比如Web Server与App Server 2.希望监控其他容器的网络流量，比如运行在独立容器中的网络监控程序。 将容器与外部世界连接 容器访问外部世界 容器默认能访问外网，这里的外网指容器网络以外的网络环境，并非特指Intenet. 当busybox从容器向外ping时，数据包是如何到达bing.com 关键是NAT 查看docker host上的iptables规则 iptables -t nat -S 含义：如果网桥docker0收到来自172.17.0.0/16网段的外出包，把它交给MASQUERADE处理，即将包的源地址替换成host地址发送出去，做了一次网路地址转换（NAT） 默认路由通过eth0发出，需要监控eth0和docker0 当busybox ping bing.com时，tcpdump输出如下 外部世界访问容器 端口映射 docker可将容器对外提供服务的端口映射到host的某端口，外网通过该端口访问容器。 -p参数映射端口 指定端口映射 docker run -d -p 8080:80 httpd 每个映射的端口，host都会启动一个docker-proxy进程来处理访问容器的流量 ps -ef|grep docker-proxy By Dazzle Lin            updated 2019-07-02 15:34:23 "},"Chapter2/Docker存储.html":{"url":"Chapter2/Docker存储.html","title":"Docker存储","keywords":"","body":"docker为容器提供了两种存放数据的资源 1.由storage drive管理的数据层（镜像层和容器层） 2.Data Volume storage driver 特性 Copy-on-Write 1.新数据会直接存放在最上面的容器层 2.修改现有数据会先从镜像层将数据复制到容器层，修改后的数据直接保存在容器层中，镜像层保持不变 3.如果多个层中有命名相同的文件，用户只能看到最上层的文件 功能 实现了多层数据的堆叠并为用户提供了一个单一的合并之后的统一视图 Docker支持多种storage driver,有AUFS、Device Mapper、Btrfs、OverlayFS、VFS和ZFS 如何选择storage driver 优先使用Linux发行版默认的storage driver 查看linux环境默认的driver docker info driver使用Overlay2，底层文件系统extfs。 对于某些容器，直接将数据放在由storage driver维护的层中是最好的选择，比如那些无状态的应用。无状态意味着容器没有需要持久化的数据，随时可以从镜像直接创建 DataVolume 适用于持久化数据需求，容器启动时需要加载已有数据，容器销毁时希望保留产生的新数据，也就是说容器有状态。 本质 Docker Host文件系统中的目录或文件，能够直接被mount到容器的文件系统中 特点 1.Data Volume是目录或文件，而非没有格式化的磁盘（块设备） 2.容器可以读写volume中的数据 3.volume数据可以被永久地保存，即使使用它的容器已经销毁 现在我们有数据层（镜像层和容器层）和volume都可以用来存放数据。 具体使用场景 1.Database软件 vs Database数据 2.Web 应用 vs 应用产生的日志 3.数据分析软件 vs input/output数据 4.Apache Server vs 静态HTML文件 前者放在数据层，因为无状态，可作为镜像一部分 后者需要持久化存储，与镜像分开，因此放在Data volume中 目前无法设置volume的容量（volume是docker host的一部分，容量取决于文件系统当前未使用的空间） volume类型 bind mount 将Host上已存在的目录或文件mount到容器 -v将其mount到httpd容器 -v格式 : docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs httpd /usr/local/apache2/htdocs就是Apache Server存放静态文件的地方。由于路径已经存在，原有数据会被隐藏，替换成~/htdocs/中的数据。 bind mount可以让host与容器共享数据。 即使容器销毁了，bind mount依然存在。 指定数据的读写权限 docker run -d -p 80:80 -v ~/htdocs:/usr/local/apache2/htdocs:ro httpd 默认可读可写。 ro设置只读权限，在容器中无法对bind mount数据进行修改，只有host有权修改 除了bind mount目录，可单独指定一个文件 将html文件加到apache中，同时保留了容器原有的数据 docker run -d -p 80:80 -v ~/htdocs/index.html:/usr/local/apache2/htdocs/new_index.html httpd curl 127.0.0.1:80 curl 127.0.0.1:80/new_index.html 使用场景 只需要向容器添加文件，不希望覆盖整个目录。 注意：host中的源文件必须存在，不然当作一个新目录bind mount给容器 ***缺点*** bind mount需要指定host文件系统的特定路径，限制了容器可移植性 ## docker managed volume ***与前者最大的区别*** 不需要指定mount源，指明mount point即可。 通过-v告诉docker需要一个data volume,并将其Mount到/usr/local/apache2/htdocs. ``` docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd ``` 在容器的配置信息中可以找到data volume所在 ``` docker inspect image长ID ``` Source就是该volume在host上的目录 原理 每当容器申请mount docker maneged volume时，docker都会在/var/lib/docker/volumes下生成一个目录，即mount源 如果mount point指向的是已有目录，原有数据会被复制到volume中。但此时该目录已经不再是由storage driver管理的层数据，而是data volume docker volume 只能查看docker managed volume（目前不支持bind volume查看） docker volume ls docker volume inspect image长ID docker inspect..... 可查看volume信息和容器 两者区别 不同点 bind volume docker managed volume volume位置 可任意指定 /var/lib/docker/volumes/... 对已有mount point影响 隐藏并替换为volume 原有数据复制到volume 是否支持单文件 支持 不支持，只能目录 权限控制 可设置只读，默认读写 无控制，读写操作 移植性 弱，与host path绑定 强，无须指定host目录 数据共享（volume特性） 容器与host共享数据 bind mount:直接将要共享的目录mount到容器 docker managed volume：由于volume位于host中的目录，是在容器启动时才生成，所以需要将共享数据复制到volume中。 docker run -d -p 80:80 -v /usr/local/apache2/htdocs httpd docker cp ~/htdocs/index.html image短ID:/usr/local/apache2/htdocs docker cp 可以在容器和host之间复制数据 容器之间共享数据 将共享数据放在bind mount中，然后将其mount到多个容器。 1.将$HOME/htdocs mount到三个httpd容器 docker run --name webn -d -p 80 -v ~/htdocs:/usr/local/apache2/htdocs httpd 2.查看当前主页 docker ps curl 127.0.0.1:3277n 3.修改volume中的主页文件，再查看并确认所有容器都使用了新主页 echo \"修改内容\" > ~/htdocs/index.html curl 127.0.0.1:3277n 另一种使用volume container volume container volume container是专门为其他容器提供volume的容器。提供的卷可以是bind mount，docker managed volume。创建volume container docker create --name vc_data \\ > -v ~/htdocs:/usr/local/apache2/htdocs \\ > -v /other/useful/tools \\ > busybox 分析 1.volume container的作用只是提供数据，它本身不需要处于运行状态，因此只执行docker create 2.容器mount两个volume: ​ bind mount，存放Web Server的静态文件 ​ docker managed volume,存放一些实用工具 3.查看这两个volume docker inspect vc_data 4.其他容器可以通过--volumes-from使用vc_data这个volume container docker run --name webn -d -p 80 --volumes-from vc_data httpd 特点 1.与bind mount相比，不必为每一个容器指定host path，所有path都在volume container中定义好了，容器只需与volume container关联，实现了容器与host的解耦 2.使用volume mount的容器，其mount point是一致的，有利于配置的规范和标准化 data-packed volume container 将数据完全放到volume container中，同时又能与其他容器共享 原理 将数据打包到镜像中，通过docker managed volume共享 实例 1.Dockerfile构建镜像 FROM busybox:latest ADD htdocs /usr/local/apache2/htdocs VOLUME /usr/local/apache2/htdocs ADD将静态文件添加到容器目录/usr/local/apache2/htdocs VOLUME作用与-v等效，用来创建docker managed volume，mount point为/usr/local/apache2/htdocs，因为这个目录就是ADD添加的目录，所以会将已有数据复制到volume中。 2.build新镜像datapacked docker build -t datapacked 3.用新镜像创建data-packed volume container docker create --name vc_data datapacked 因为在Dockerfile中已经使用了VOLUME，此处无须指定volume的mount point 4.启动httpd容器并使用data-pack volume container docker run -d -p 80:80 --volumes-from vc_data httpd 优点 容器可以正确读取volume中的数据，data-packed volume container是自包含的，不依赖host提供数据，具有强移植性 适用场景 只使用静态数据的场景，比如应用的配置信息、Web server的静态文件 Data Volume生产周期管理 备份 volume实际上是host文件系统中的目录和文件，所以volume的备份实际上是对文件系统的备份 之前的搭建本地Registry docker run -d -p 5000:5000 -v /myregistry:/var/lib/registry registry:2 所有本地镜像都保存在host的/myregistry目录中，我们要做的就是定期备份这个目录。 恢复 如果数据损坏，直接用之前备份的数据复制到/myregistry即可 迁移 如果我们想使用更新版本的Registry，涉及数据迁移 1.docker stop当前Registry容器 2.启动新版本容器并mount原有volume docker run -d -p 5000:5000 -v /myregistry:/var/lib/registry registry:latest 在启用新容器前要确保新版本的默认路径是否发生变化 销毁 可以删除不需要的volume，但删除后数据无法找回 docker不会销毁bind mount，删除数据的工作只能由host负责。 docker managed volume在执行docker rm 删除容器时可以带上-v参数，docker会将容器使用到的volume一并删除，但前提是没有其他容器mount该volume.目的是保护数据，非常合理。 如果删除容器没带-v，会产生孤儿volume。可通过docker提供的volume子命令对docker managed volume进行维护如下: docker volume ls docker run --name bbox -v /test/data busybox 忘记带-v docker rm bbox docker volume ls 删除单个volume docker volume rm volume_name 批量删除 docker volume rm $(docker volume ls -q) By Dazzle Lin            updated 2019-07-02 15:39:28 "}}